"use client";
import * as THREE from "three";
import React, { Suspense } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { Canvas, Vector3 } from '@react-three/fiber'
import { Loader, OrbitControls, Stage } from '@react-three/drei'
import { useSpring, useSprings, animated, SpringValues, to  } from '@react-spring/three'
import { useKey } from "react-use";
import { Syne_Mono } from 'next/font/google'


const Page = () => {
  return (
    <>
      <Suspense fallback={null}>
        <Canvas shadows dpr={[1, 2]} camera={{ fov: 50 }}>
          <Stage preset="rembrandt" intensity={1}  environment="city">
            <Model />
          </Stage>
          <OrbitControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2} />
        </Canvas>
      </Suspense>
      <Loader />
    </>
  )
}

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

type GLTFResult = GLTF & {
  nodes: {
    Plane: THREE.Mesh;
    Cylinder: THREE.Mesh;
    Grid: THREE.Mesh;
    Cube: THREE.Mesh;
  };
  materials: {
    inch_grid: THREE.MeshStandardMaterial;
    characters_grid: THREE.MeshStandardMaterial;
  };
};

type MySpringValues = SpringValues<{
  position: THREE.Vector3Tuple
}>


export function Model(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/model/paperpen.gltf") as GLTFResult;
  
  const key_filter = ['ArrowDown','ArrowUp','ArrowLeft','ArrowRight',' ']
  const filter = (event) => key_filter.includes(event.key)

  const downer = (vect:THREE.Vector3Tuple, key:string): THREE.Vector3Tuple  => {

    switch(key){
      case 'ArrowUp':
        return [vect[0] + 0.0896, vect[1], vect[2]]
      case 'ArrowDown':
        return [vect[0] - 0.0896, vect[1], vect[2] ]
      case 'ArrowLeft':
        return [vect[0], vect[1] , vect[2] + 0.0537]
      case 'ArrowRight':
        return [vect[0], vect[1] , vect[2] - 0.0537]
      case ' ':
        return [vect[0], 0, vect[2]]
      default:
        return vect
    }
  }

  const upper = (vect:THREE.Vector3Tuple, key:string): THREE.Vector3Tuple => {

    switch(key){
      case ' ':
        return [vect[0], 0.3, vect[2]]
      default:
        return vect
    }
  }

  const press = (event) => {
    const vect3 = springs.position.get()
    if(event.type=="keydown"){
      const newvect = downer(vect3, event.key)
      api.start({
        position: newvect,
      })
    }else if(event.type=="keyup"){
      const newvect = upper(vect3, event.key)
      api.start({
        position: newvect,
      })
    }
  }
  

  const f = (event) => event.key.match(/\w/)
  const log = (e) => {
    console.log(e.key + " is ")
  }

  useKey(f, log, { event: 'keydown' });
  useKey(filter, press, { event: 'keydown' });
  useKey(filter, press, { event: 'keyup' });

  const [springs, api] = useSpring<MySpringValues>(
    () => ({
      position: [2.424, 0.3, -1.493],
      config: { mass: 0.5, friction: 30, tension: 700, precision: 0.0001 }
    }),
    []
  )

  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane.geometry}
        material={nodes.Plane.material}
      />
      <animated.mesh
        castShadow
        receiveShadow
        geometry={nodes.Cylinder.geometry}
        material={nodes.Cylinder.material}
        position={springs.position}
        scale={[0.5, 1, 0.5]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Grid.geometry}
        material={materials.inch_grid}
        position={[-0.064, 0.01, 0]}
        scale={[3.037, 2.025, 2.025]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={materials.characters_grid}
        position={[2.424, 0.01, -1.493]}
        rotation={[0, Math.PI / 2, 0]}
        scale={[0.025, 0.05, 0.042]}
      />
    </group>
  );
}

useGLTF.preload("/model/paperpen.gltf");



export default Page
